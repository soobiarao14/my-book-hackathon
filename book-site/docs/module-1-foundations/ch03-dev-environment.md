# Chapter 3: Development Environment Setup

## Learning Objectives

By the end of this chapter, you will be able to:
- Install ROS 2 Humble on Ubuntu 22.04
- Set up Gazebo Classic simulation environment
- Create and build your first ROS 2 workspace
- Write a basic publisher-subscriber node using rclpy
- Understand the ROS 2 build system (colcon)
- Configure VS Code for ROS 2 development

## Prerequisites

Before starting this chapter, ensure you have:
- Ubuntu 22.04 LTS installed (native or WSL2)
- Basic familiarity with Linux terminal
- Python 3.10+ knowledge
- At least 20GB free disk space

## 3.1 Installing ROS 2 Humble

ROS 2 (Robot Operating System 2) is the middleware framework we'll use throughout this book. ROS 2 Humble Hawksbill is the Long-Term Support (LTS) release supported until 2027.

### Why ROS 2?

- **Distributed Communication**: Nodes communicate via DDS (Data Distribution Service)
- **Real-time Capable**: Supports deterministic execution for safety-critical systems
- **Cross-platform**: Works on Linux, Windows, macOS
- **Language Support**: Python (rclpy) and C++ (rclcpp) client libraries

### Installation Steps

```bash
# Set up ROS 2 apt repository
sudo apt update && sudo apt install -y curl gnupg lsb-release
sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key \
  -o /usr/share/keyrings/ros-archive-keyring.gpg

echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] \
  http://packages.ros.org/ros2/ubuntu $(lsb_release -cs) main" | \
  sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null

# Install ROS 2 Humble Desktop (includes RViz, tutorials, demos)
sudo apt update
sudo apt install -y ros-humble-desktop ros-dev-tools

# Source ROS 2 in your shell (add to ~/.bashrc for persistence)
echo "source /opt/ros/humble/setup.bash" >> ~/.bashrc
source ~/.bashrc

# Verify installation
ros2 --version
# Expected output: ros2 cli version 0.18.x
```

### Troubleshooting

**Issue**: `ros2: command not found`
**Solution**: Ensure you've sourced the setup script: `source /opt/ros/humble/setup.bash`

**Issue**: Package installation fails with GPG error
**Solution**: Re-add the ROS GPG key using the curl command above

---

## 3.2 Installing Gazebo Classic 11

Gazebo is our primary simulation environment for testing robots before deploying to hardware.

```bash
# Install Gazebo and ROS 2 bridge
sudo apt install -y gazebo libgazebo11 ros-humble-gazebo-ros-pkgs

# Verify installation
gazebo --version
# Expected: Gazebo multi-robot simulator, version 11.x

# Test Gazebo with a simple world
gazebo --verbose
```

**Performance Tip**: If Gazebo runs slowly, reduce the real-time update rate:
```bash
export GAZEBO_RESOURCE_PATH=/usr/share/gazebo-11
gazebo --verbose -u  # -u starts paused
```

---

## 3.3 Creating Your First ROS 2 Workspace

A ROS 2 workspace is a directory structure where you build and organize your packages.

### Workspace Structure

```
~/ros2_ws/
├── src/              # Source code for your packages
├── build/            # Build artifacts (generated by colcon)
├── install/          # Installed packages
└── log/              # Build logs
```

### Initialize Workspace

```bash
# Create workspace directory
mkdir -p ~/ros2_ws/src
cd ~/ros2_ws

# Build the workspace (even though src/ is empty)
colcon build --symlink-install

# Source the workspace overlay
source install/setup.bash
```

The `--symlink-install` flag creates symbolic links instead of copying files, speeding up iteration during development.

---

## 3.4 Your First ROS 2 Node: Publisher & Subscriber

Let's create a simple package that demonstrates the core ROS 2 communication pattern: **publishers and subscribers**.

### Creating a Python Package

```bash
cd ~/ros2_ws/src

# Create a Python package named "hello_robot"
ros2 pkg create --build-type ament_python hello_robot \
  --dependencies rclpy std_msgs

cd hello_robot
```

This creates:
- `package.xml`: Package metadata and dependencies
- `setup.py`: Python package configuration
- `hello_robot/`: Python module directory

---

### Writing a Publisher Node

Create `hello_robot/publisher_node.py`:

```python
#!/usr/bin/env python3
"""
Simple ROS 2 Publisher Node
Publishes "Hello Robot" messages to /chatter topic

Documentation fetched via MCP Context7: /ros2/rclpy
API Reference: https://github.com/ros2/rclpy
"""

import rclpy
from rclpy.node import Node
from std_msgs.msg import String


class HelloPublisher(Node):
    """
    Publisher node that sends periodic messages.

    ROS 2 Node API (from MCP Context7):
    - Node.create_publisher(msg_type, topic, qos_profile)
    - Node.create_timer(timer_period_sec, callback)
    - Node.get_logger() - Access node's logger
    """

    def __init__(self):
        # Initialize the node with name 'hello_publisher'
        super().__init__('hello_publisher')

        # Create publisher for String messages on /chatter topic
        # QoS depth=10 means buffer up to 10 messages
        self.publisher_ = self.create_publisher(String, 'chatter', 10)

        # Create timer that calls publish_message() every 1.0 seconds
        self.timer = self.create_timer(1.0, self.publish_message)

        self.counter = 0
        self.get_logger().info('Hello Publisher Node started!')

    def publish_message(self):
        """Timer callback: publish a message to /chatter topic"""
        msg = String()
        msg.data = f'Hello Robot #{self.counter}'

        # Publish the message
        self.publisher_.publish(msg)

        # Log to console (visible in terminal)
        self.get_logger().info(f'Publishing: "{msg.data}"')

        self.counter += 1


def main(args=None):
    # Initialize ROS 2 Python client library
    rclpy.init(args=args)

    # Create and spin the node (processes callbacks)
    node = HelloPublisher()

    try:
        rclpy.spin(node)  # Blocks until shutdown
    except KeyboardInterrupt:
        pass
    finally:
        # Clean shutdown
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

**Key Concepts** (from MCP Context7 rclpy API):
- **Node**: Base class for all ROS 2 components
- **Publisher**: Sends messages to a topic (`create_publisher()`)
- **Timer**: Executes callbacks at regular intervals (`create_timer()`)
- **Logger**: Thread-safe logging (`get_logger()`)

---

### Writing a Subscriber Node

Create `hello_robot/subscriber_node.py`:

```python
#!/usr/bin/env python3
"""
Simple ROS 2 Subscriber Node
Listens to /chatter topic and prints received messages

Documentation fetched via MCP Context7: /ros2/rclpy
"""

import rclpy
from rclpy.node import Node
from std_msgs.msg import String


class HelloSubscriber(Node):
    """
    Subscriber node that receives messages from /chatter topic.

    ROS 2 Subscription API (from MCP Context7):
    - Node.create_subscription(msg_type, topic, callback, qos_profile)
    - Thread-safe subscription destruction (rclpy v3.3+)
    """

    def __init__(self):
        super().__init__('hello_subscriber')

        # Create subscription to /chatter topic
        self.subscription = self.create_subscription(
            String,
            'chatter',
            self.message_callback,
            10  # QoS depth
        )

        self.get_logger().info('Hello Subscriber Node started! Waiting for messages...')

    def message_callback(self, msg):
        """Callback executed when a message is received"""
        self.get_logger().info(f'Received: "{msg.data}"')


def main(args=None):
    rclpy.init(args=args)
    node = HelloSubscriber()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

---

### Configuring the Package

Edit `setup.py` to register the nodes as executables:

```python
from setuptools import setup

package_name = 'hello_robot'

setup(
    name=package_name,
    version='0.0.1',
    packages=[package_name],
    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='Your Name',
    maintainer_email='you@example.com',
    description='Simple ROS 2 publisher-subscriber example',
    license='Apache-2.0',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'publisher = hello_robot.publisher_node:main',
            'subscriber = hello_robot.subscriber_node:main',
        ],
    },
)
```

---

### Building and Running

```bash
# Navigate to workspace root
cd ~/ros2_ws

# Build the package
colcon build --packages-select hello_robot

# Source the workspace (loads newly built packages)
source install/setup.bash

# Run the publisher in one terminal
ros2 run hello_robot publisher

# In a new terminal, run the subscriber
ros2 run hello_robot subscriber
```

**Expected Output:**

Terminal 1 (Publisher):
```
[INFO] [hello_publisher]: Hello Publisher Node started!
[INFO] [hello_publisher]: Publishing: "Hello Robot #0"
[INFO] [hello_publisher]: Publishing: "Hello Robot #1"
[INFO] [hello_publisher]: Publishing: "Hello Robot #2"
...
```

Terminal 2 (Subscriber):
```
[INFO] [hello_subscriber]: Hello Subscriber Node started! Waiting for messages...
[INFO] [hello_subscriber]: Received: "Hello Robot #0"
[INFO] [hello_subscriber]: Received: "Hello Robot #1"
[INFO] [hello_subscriber]: Received: "Hello Robot #2"
...
```

---

## 3.5 Understanding the ROS 2 Build System

### colcon: The ROS 2 Build Tool

`colcon` (collective construction) is the build system for ROS 2 workspaces.

**Common Commands:**

```bash
# Build all packages
colcon build

# Build specific package
colcon build --packages-select hello_robot

# Build with symbolic links (faster iteration)
colcon build --symlink-install

# Build with verbose output (for debugging)
colcon build --event-handlers console_direct+

# Clean build artifacts
rm -rf build/ install/ log/
```

### Package Dependencies

Edit `package.xml` to declare dependencies:

```xml
<?xml version="1.0"?>
<package format="3">
  <name>hello_robot</name>
  <version>0.0.1</version>
  <description>Simple publisher-subscriber example</description>
  <maintainer email="you@example.com">Your Name</maintainer>
  <license>Apache-2.0</license>

  <!-- Build tool dependency -->
  <buildtool_depend>ament_python</buildtool_depend>

  <!-- Runtime dependencies (fetched via MCP Context7) -->
  <exec_depend>rclpy</exec_depend>
  <exec_depend>std_msgs</exec_depend>

  <export>
    <build_type>ament_python</build_type>
  </export>
</package>
```

---

## 3.6 Configuring VS Code for ROS 2

### Recommended Extensions

```bash
# Install VS Code extensions
code --install-extension ms-python.python
code --install-extension ms-vscode.cpptools
code --install-extension ms-iot.vscode-ros
code --install-extension eamodio.gitlens
```

### Workspace Settings

Create `.vscode/settings.json`:

```json
{
  "python.autoComplete.extraPaths": [
    "/opt/ros/humble/lib/python3.10/site-packages",
    "${workspaceFolder}/install/hello_robot/lib/python3.10/site-packages"
  ],
  "python.analysis.extraPaths": [
    "/opt/ros/humble/lib/python3.10/site-packages"
  ],
  "ros.distro": "humble",
  "files.exclude": {
    "**/build": true,
    "**/install": true,
    "**/log": true
  }
}
```

This enables autocomplete for ROS 2 APIs and hides build artifacts.

---

## Summary

In this chapter, you've:
- ✅ Installed ROS 2 Humble and Gazebo 11
- ✅ Created a ROS 2 workspace
- ✅ Written your first publisher and subscriber nodes
- ✅ Learned the colcon build system
- ✅ Configured VS Code for ROS 2 development

### Key Takeaways

1. **ROS 2 Nodes**: Modular components that communicate via topics
2. **Publishers**: Send messages to topics
3. **Subscribers**: Receive messages from topics
4. **colcon**: Build tool for ROS 2 workspaces
5. **rclpy**: Python client library (API docs via MCP Context7)

---

## Exercises

### Exercise 3.1: Modify the Message

Modify `publisher_node.py` to publish the current timestamp along with the message.

**Hint**: Use `import time` and `time.time()`

### Exercise 3.2: Create a New Topic

Create a new publisher-subscriber pair that communicates on `/robot_status` topic using `std_msgs/String`.

### Exercise 3.3: Quality of Service (QoS)

Experiment with different QoS profiles:
- Change QoS depth from 10 to 1
- Use `rclpy.qos.QoSProfile` to configure reliability and durability

**Reference** (from MCP Context7):
```python
from rclpy.qos import QoSProfile, ReliabilityPolicy

qos_profile = QoSProfile(depth=10)
qos_profile.reliability = ReliabilityPolicy.BEST_EFFORT

self.publisher_ = self.create_publisher(String, 'chatter', qos_profile)
```

---

## Project 1.3: Spawn a Robot in Gazebo

### Objective
Launch Gazebo, spawn a simple robot model (URDF), and visualize it in RViz.

### Steps

1. **Create a URDF Model** (`hello_robot/urdf/simple_robot.urdf`):
```xml
<?xml version="1.0"?>
<robot name="simple_robot">
  <link name="base_link">
    <visual>
      <geometry>
        <box size="0.5 0.3 0.2"/>
      </geometry>
      <material name="blue">
        <color rgba="0 0 1 1"/>
      </material>
    </visual>
  </link>
</robot>
```

2. **Create Launch File** (`hello_robot/launch/gazebo.launch.py`):
```python
from launch import LaunchDescription
from launch_ros.actions import Node
import os
from ament_index_python.packages import get_package_share_directory

def generate_launch_description():
    urdf_file = os.path.join(
        get_package_share_directory('hello_robot'),
        'urdf', 'simple_robot.urdf'
    )

    return LaunchDescription([
        Node(
            package='gazebo_ros',
            executable='spawn_entity.py',
            arguments=['-entity', 'simple_robot', '-file', urdf_file],
            output='screen'
        ),
    ])
```

3. **Launch Gazebo and Spawn Robot**:
```bash
# Terminal 1: Start Gazebo
gazebo --verbose

# Terminal 2: Spawn the robot
ros2 launch hello_robot gazebo.launch.py
```

You should see a blue box representing your robot in Gazebo!

---

## Further Reading

- [ROS 2 Humble Documentation](https://docs.ros.org/en/humble/) - Official docs
- [rclpy API Reference (via MCP Context7)](/ros2/rclpy) - Python client library
- [ROS 2 Tutorials](https://docs.ros.org/en/humble/Tutorials.html) - Hands-on guides
- [Gazebo Tutorials](https://classic.gazebosim.org/tutorials) - Simulation guides

---

## References

1. ROS 2 rclpy GitHub Repository. Retrieved 2025-12-06 via MCP Context7. https://github.com/ros2/rclpy
2. Macenski, S., Foote, T., Gerkey, B., Lalancette, C., & Woodall, W. (2022). Robot Operating System 2: Design, architecture, and uses in the wild. *Science Robotics*, 7(66).
3. Gazebo Classic Documentation. (2024). http://classic.gazebosim.org/

---

**Next Chapter**: [Chapter 4: Computer Vision Fundamentals for Robotics →](../module-2-perception/ch04-computer-vision.md)

---

*This chapter uses up-to-date API documentation fetched via MCP Context7 server to ensure accuracy as of December 2025.*
